module test_euler_mod
    use pfunit_mod
    use mod_kinds,          only: rk,ik
    use mod_constants,      only: ZERO, ONE, TWO, THREE, FIVE, SIX, EIGHT, NINE, TEN, &
                                  XI_MIN, XI_MAX, ETA_MIN, ETA_MAX, ZETA_MIN, ZETA_MAX, NFACES

    use type_chidg,         only: chidg_t
    use atype_function,     only: function_t
    use mod_function,       only: create_function
    use mod_grid_operators, only: initialize_variable
    use type_point,         only: point_t
    use type_densematrix,   only: densematrix_t
    use mod_testutils,      only: meshgen
    use mod_check_jacobian
    implicit none

    public  :: test_eq_euler


    ! This parameter is used to test the linearization for different blocks.
    ! iblk = [XI_MIN, XI_MAX, ETA_MIN, ETA_MAX, ZETA_MIN, ZETA_MAX, DIAG]
    @TestParameter(constructor=newBlock)
    type, extends (AbstractTestParameter) :: blockParam
        integer(ik)         :: iblk
    contains
        procedure :: toString
    end type blockParam
    
    
    
    @TestCase(constructor=newTest)
    type, extends(ParameterizedTestCase) ::  test_eq_euler
        type(chidg_t)       :: chidg
        integer(ik)         :: iblk
    contains
        procedure   ::  setUp
        procedure   ::  tearDown
    end type test_eq_euler





contains
    !------------------------
    !> SET-UP  +  TEAR-DOWN
    !------------------------

    !> NOTE: make sure to use 'this' instead of 'self' since these are over-writting a derived type 
    !! procedure. The argument names have to match
    subroutine setUp(this)
        class(test_eq_euler),    intent(inout)   :: this
        
        integer(ik),        parameter       :: npt = 64
        type(point_t),      allocatable     :: pts(:,:,:)
        class(function_t),  allocatable     :: fcn
        integer(ik)                         :: neqns, nterms_s, nterms_c
        real(rk), dimension(npt)            :: x,y,z
        
        !
        ! Initialize chidg environment
        !
        call this%chidg%init('env')

        ! Generate points array for 3x3x3 mesh
        call meshgen('3x3x3',pts)

        !
        ! Add domain to ChiDG
        !
        nterms_s = 8
        nterms_c = 8
        call this%chidg%data%add_domain('D_01',pts,nterms_c,'euler',nterms_s)
        call this%chidg%data%init_sdata()



        ! Set rho, rhoE to non-zero values. Risk NaN's otherwise
        call create_function(fcn,'constant')
        
        call fcn%set('const',1.0_rk)
        call initialize_variable(this%chidg%data,1,fcn)
        call fcn%set('const',1.1_rk)
        call initialize_variable(this%chidg%data,2,fcn)
        call fcn%set('const',1.2_rk)
        call initialize_variable(this%chidg%data,3,fcn)
        call fcn%set('const',1.3_rk)
        call initialize_variable(this%chidg%data,4,fcn)
        call fcn%set('const',6.0_rk)
        call initialize_variable(this%chidg%data,5,fcn)
            
    end subroutine
    
    subroutine tearDown(this)
        class(test_eq_euler),    intent(inout)   :: this


        !
        ! Close ChiDG interface
        !
        call this%chidg%close()
    end subroutine


    !--------------------------
    ! PARAMETER CONSTRUCTORS
    !--------------------------
    
    ! Function for setting the correct parameter value in the constructor
    function newBlock(iblk) result(param)
        type(blockParam)        :: param
        integer(ik), intent(in) :: iblk
        
        param%iblk = iblk
    end function newBlock
    
    ! TestCase constructor for parameter specification
    function newTest(param)
        type(test_eq_euler) :: newTest
        type(blockParam)                    :: param
        
        newTest%iblk = param%iblk
    end function newTest

    ! ToString - not sure what this is for yet
    function toString(this) result(string)
        class(blockParam), intent(in)   :: this
        character(:), allocatable       :: string
        character(len=3)                :: str
         
        write(str,'(i0)') this%iblk
        string = str
    end function toString



!------------------------------------------------------------------------------------------
!>                                        TESTS
!------------------------------------------------------------------------------------------
!> Test Volume Flux jacobian calclation
!@Test(cases = [1, 2, 3, 4, 5, 6, 7])
@Test(cases = [7])
    subroutine test_EULER_jacobian_volume_advective_flux(self)
        class(test_eq_euler),    intent(inout)   :: self
        
        type(densematrix_t) :: blk_dnad, blk_fd
        integer(ik) :: ielem, iblk
        real(rk)    :: tol
        
        tol = 1.0e-5_rk
        
        ielem = 14
        
        ! Block Parameter from cases = []
        iblk = self%iblk
        
        ! Compute Automatic and Finite Difference jacobians
        call check_jacobian_volume_advective_flux(self%chidg%data,ielem,iblk,blk_dnad,blk_fd)
        
                
        @assertEqual(blk_fd%mat, blk_dnad%mat, tol)
        
    end subroutine
    
    


!> Test Boundary Advective Flux jacobian calculation
@Test(cases = [1, 2, 3, 4, 5, 6, 7])
    subroutine test_EULER_jacobian_boundary_advective_flux(self)
        class(test_eq_euler),    intent(inout)   :: self
        
        type(densematrix_t) :: blk_dnad, blk_fd
        integer(ik) :: ielem, iface, ivar, iblk, irow
        real(rk)    :: tol
        
        tol = 1.0e-5_rk
        
        ielem = 14
        !ielem = 1
        
        ! Block Parameter from cases = []
        iblk = self%iblk
        
        ! Compute Automatic and Finite Difference jacobians
        call check_jacobian_boundary_advective_flux(self%chidg%data,ielem,iblk,blk_dnad,blk_fd)
        
        
        @assertEqual(blk_fd%mat, blk_dnad%mat, tol)
        
    end subroutine
    
    
    






end module test_euler_mod
